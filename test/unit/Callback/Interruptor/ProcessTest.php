<?php
/**
 * @copyright Copyright Â© 2014 Rollun LC (http://rollun.com/)
 * @license LICENSE.md New BSD License
 */

namespace rollun\test\unit\Interruptor\Callback;

use PHPUnit\Framework\TestCase;
use Psr\Log\LoggerInterface;
use rollun\callback\Callback\CallbackException;
use rollun\callback\Callback\SerializedCallback;
use rollun\callback\Callback\Interrupter\Process;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-10-13 at 12:52:54.
 */
class ProcessTest extends TestCase
{
    public function testParallelProcess()
    {
        $callback = new SerializedCallback(function ($file) {
            sleep(1);
            $time = microtime(1);
            file_put_contents($file, "$time\n", FILE_APPEND);
        });

        $outPutFile = "data/testOutput.dat";

        (new Process($callback))($outPutFile);
        (new Process($callback))($outPutFile);
        sleep(3);
        $timeData = file_get_contents($outPutFile);
        list($firstTime, $secondTime) = explode("\n", $timeData);
        if (abs($firstTime - $secondTime) < 0.5) {
            $result = 'parallel';
        } else {
            $result = 'in series';
        }
        if (substr(php_uname(), 0, 7) === "Windows") {
            $this->assertEquals('in series', $result);
        } else {
            $this->assertEquals('parallel', $result);
        }

        unlink($outPutFile);
    }

    public function testUnserializedCallbackProcess()
    {
        global $container;

        $logFile = 'data/testOutput.log';

        $callback = new SerializedCallback(new class {
            public function __invoke(){}
        });

        $logger = $container->get(LoggerInterface::class);
        foreach ($logger->getWriters() as $key => $writer) {
            $writer->shutdown();
        }
        $logger->addWriter(new Stream($logFile));

        $process = new Process($callback, null, null, $logger);

        $this->expectException(CallbackException::class);

        $process();

        unlink($logFile);
    }

    public function testUnserializedCallbackProcessLogging()
    {
        global $container;

        $logFile = 'data/testOutput.log';

        $callback = new SerializedCallback(new class {
            public function __invoke(){}
        });

        $logger = $container->get(LoggerInterface::class);
        foreach ($logger->getWriters() as $key => $writer) {
            $writer->shutdown();
        }
        $logger->addWriter(new Stream($logFile));

        $process = new Process($callback, null, null, $logger);

        try {
            $process();
        } catch (\Throwable $exception) {

        }

        $log = file_get_contents($logFile);
        $this->assertNotEmpty($log);



        unlink($logFile);
    }
}
